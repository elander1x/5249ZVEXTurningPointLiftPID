#include "robot-config.h"
/*
 *PID Lift Code (Draft #1)
 *@author Jon Poret (Base by Karthik Selveraj)
 *November 15, 2018
 *Changes-
 * This code is a modified version of Karthik's Chassis PID code that is being used for the lift.
*/
//PID FWD & REV Chassis Movement
void PIDLift(double dist)
{
    //Resets the left and right of the lifts motor by setting the encoder to zero
    RightLift.resetRotation();
    LeftLift.resetRotation();
    
    //Determines the distance  of how far up the lift will go 720(angle)*dist(a set amount how)/ 0.7(the set size/diameter of the gear)*M_PI(circle[used for determinng circumference])
    double goal = (720*dist)/(0.7*M_PI);
    
    //Gain is the ratio of output change (%) over the measured variable change (%) that caused it
    //P
    //I = 1/[(loop period in minutes)*2]
    //D = (loop period in minutes)/8
    double pGain = 0.0;
    double iGain = 0.0;
    double dGain = 0.0;
    
    //
    double error = RightLift;
    double oldError = RightLift.rotation(vex::rotationUnits::deg) = 0.0;
    
    //
    bool isFirst = true;
    int counter = 0;
    //
    int i = 0;
    Timer.clear();
    double oldSpeed = 0.0;
    
    while(error > 20.0){
        error = goal - RightLift.rotation(vex::rotationUnits::deg);
        errorSum += (error);
        if(error == 0.0){
            errorSum = 0.0;
        }
       
        double change = error - oldError;
        
        double difference = RightChassis.rotation(vex::rotationUnits::deg) - LeftChassis.rotation(vex::rotationUnits::deg);
        double motorSpeed = (error*pGain) + ((1.0/errorSum)*(iGain)) + (change*dGain);
        if(motorSpeed <= 30.0){
            motorSpeed = 30.0;
        }
        RightLift.spin(vex::directionType::fwd, motorSpeed, vex::velocityUnits::rpm);
        LeftLift.spin(vex::directionType::fwd, motorSpeed,vex::velocityUnits::rpm);
        
        oldError = error;
        
        if(oldSpeed >= 0.0 && motorSpeed < 0.0 && isFirst == true)
        {
            isFirst = false;
            oldSpeed = motorSpeed;
            Brain.resetTimer(); 
            continue;
        }
        else if(oldSpeed < 0.0 && motorSpeed > 0.0 && isFirst == false){
            counter++;
        }
        else if(oldSpeed > 0.0 && motorSpeed < 0.0 && isFirst == false){
            counter++;
        }
        else{
            oldSpeed = motorSpeed;
            continue;
        }

        if(counter % 2 == 0 && counter > 1)
        {
            double currentTime = (Brain.timer(vex::timeUnits::sec));
            int add = (i-1)*10;      
            Brain.Screen.printAt(1,30 + add, true, "%f", currentTime); 
            Brain.resetTimer();
        }
        oldSpeed = motorSpeed;
        i++;
        
        vex::task::sleep(30);
    }
    
    LeftLift.stop(vex::brakeType::brake);
    RightLift.stop(vex::brakeType::brake);
    
    RightLift.resetRotation();
    LeftLift.resetRotation();
}
